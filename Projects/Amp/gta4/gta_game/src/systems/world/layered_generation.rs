use bevy::prelude::*;
use bevy_rapier3d::prelude::*;
use rand::Rng;
use crate::components::*;
use crate::constants::*;
use crate::bundles::{VehicleVisibilityBundle, VisibleChildBundle};
use crate::systems::world::unified_world::{
    UnifiedWorldManager, UnifiedChunkEntity, ContentLayer, ChunkCoord, ChunkState,
    UNIFIED_CHUNK_SIZE, LOD_DISTANCES,
};
use crate::systems::world::road_network::{RoadNetwork, RoadSpline, RoadType};
use crate::systems::world::road_mesh::{generate_road_mesh, generate_road_markings_mesh};

// LAYERED CONTENT GENERATION SYSTEMS
// These systems generate content in layers: Roads -> Buildings -> Vehicles -> Vegetation
// Each layer waits for previous layers to complete before starting

/// System that manages the progression through content generation layers
pub fn layered_generation_coordinator(
    mut world_manager: ResMut<UnifiedWorldManager>,
    chunk_query: Query<(Entity, &UnifiedChunkEntity)>,
    time: Res<Time>,
) {
    let current_time = time.elapsed_secs();
    
    // Process chunks that are in loading state
    let mut chunks_to_update = Vec::new();
    
    for (chunk_coord, chunk) in &world_manager.chunks {
        if matches!(chunk.state, ChunkState::Loading) {
            // Check if enough time has passed since last update (prevent frame drops)
            if current_time - chunk.last_update > 0.1 {
                chunks_to_update.push(*chunk_coord);
            }
        }
    }
    
    // Update chunk generation progress
    for coord in chunks_to_update {
        advance_chunk_generation(&mut world_manager, coord, current_time);
    }
}

fn advance_chunk_generation(
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    current_time: f32,
) {
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.last_update = current_time;
    
    // Determine what layer to generate next
    let next_layer = if !chunk.roads_generated {
        Some(ContentLayer::Roads)
    } else if !chunk.buildings_generated {
        Some(ContentLayer::Buildings)
    } else if !chunk.vehicles_generated {
        Some(ContentLayer::Vehicles)
    } else if !chunk.vegetation_generated {
        Some(ContentLayer::Vegetation)
    } else {
        // All layers complete - need to calculate LOD separately to avoid borrow issues
        let distance = chunk.distance_to_player;
        // Store distance first, then calculate LOD
        drop(chunk); // Release the mutable borrow
        let lod_level = world_manager.calculate_lod_level(distance);
        let chunk = world_manager.get_chunk_mut(coord); // Re-borrow
        chunk.state = ChunkState::Loaded { lod_level };
        None
    };
    
    // Mark the appropriate layer flag for the generation systems to pick up
    match next_layer {
        Some(ContentLayer::Roads) => {
            // Roads will be generated by road_layer_system
        }
        Some(ContentLayer::Buildings) => {
            // Buildings will be generated by building_layer_system
        }
        Some(ContentLayer::Vehicles) => {
            // Vehicles will be generated by vehicle_layer_system
        }
        Some(ContentLayer::Vegetation) => {
            // Vegetation will be generated by vegetation_layer_system
        }
        None => {
            // Chunk generation complete
        }
        _ => {}
    }
}

/// Layer 1: Road Generation System
pub fn road_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) && !chunk.roads_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_roads_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_roads_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    // Use existing road network generation logic but adapted for unified system
    let new_road_ids = world_manager.road_network.generate_chunk_roads(coord.x, coord.z);
    
    // Create road entities and add to placement grid
    for road_id in new_road_ids {
        if let Some(road) = world_manager.road_network.roads.get(&road_id).cloned() {
            let road_entity = spawn_unified_road_entity(
                commands,
                coord,
                road_id,
                &road,
                meshes,
                materials,
            );
            
            // Add road to placement grid
            let samples = 20;
            for i in 0..samples {
                let t = i as f32 / (samples - 1) as f32;
                let road_point = road.evaluate(t);
                world_manager.placement_grid.add_entity(
                    road_point,
                    ContentType::Road,
                    road.road_type.width() * 0.5,
                );
            }
            
            // Add entity to chunk
            let chunk = world_manager.get_chunk_mut(coord);
            chunk.entities.push(road_entity);
        }
    }
    
    // Mark roads as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.roads_generated = true;
}

fn spawn_unified_road_entity(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    road_id: u32,
    road: &RoadSpline,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) -> Entity {
    let center_pos = road.evaluate(0.5);
    
    let road_material = create_road_material(&road.road_type, materials);
    let marking_material = create_marking_material(materials);
    
    let road_entity = commands.spawn((
        UnifiedChunkEntity {
            coord: chunk_coord,
            layer: ContentLayer::Roads,
        },
        RoadEntity { road_id },
        Transform::from_translation(center_pos),
        GlobalTransform::default(),
        Visibility::default(),
        InheritedVisibility::VISIBLE,
        ViewVisibility::default(),
        DynamicContent {
            content_type: ContentType::Road,
        },
    )).id();
    
    // Road surface mesh
    let road_mesh = generate_road_mesh(road);
    commands.spawn((
        Mesh3d(meshes.add(road_mesh)),
        MeshMaterial3d(road_material),
        Transform::from_translation(-center_pos),
        ChildOf(road_entity),
        VisibleChildBundle::default(),
    ));
    
    // Road markings
    let marking_meshes = generate_road_markings_mesh(road);
    for marking_mesh in marking_meshes {
        commands.spawn((
            Mesh3d(meshes.add(marking_mesh)),
            MeshMaterial3d(marking_material.clone()),
            Transform::from_translation(-center_pos + Vec3::new(0.0, 0.01, 0.0)),
            ChildOf(road_entity),
            VisibleChildBundle::default(),
        ));
    }
    
    road_entity
}

/// Layer 2: Building Generation System
pub fn building_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) 
                && chunk.roads_generated 
                && !chunk.buildings_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_buildings_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_buildings_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    let mut rng = rand::thread_rng();
    let chunk_center = coord.to_world_pos();
    let half_size = UNIFIED_CHUNK_SIZE * 0.5;
    
    // Determine building density based on distance from center
    let distance_from_center = Vec2::new(chunk_center.x, chunk_center.z).length();
    let building_density = (1.0 - (distance_from_center / 2000.0).min(0.8)).max(0.1);
    
    // Generate building positions
    let building_attempts = (building_density * 20.0) as usize;
    
    for _ in 0..building_attempts {
        let local_x = rng.gen_range(-half_size..half_size);
        let local_z = rng.gen_range(-half_size..half_size);
        let position = Vec3::new(chunk_center.x + local_x, 0.0, chunk_center.z + local_z);
        
        // Check if position is valid (not on road, not overlapping other buildings)
        if !is_on_road_unified(position, &world_manager.road_network) {
            let building_size = rng.gen_range(8.0..15.0);
            if world_manager.placement_grid.can_place(
                position,
                ContentType::Building,
                building_size * 0.5,
                building_size,
            ) {
                let building_entity = spawn_unified_building(
                    commands,
                    coord,
                    position,
                    distance_from_center,
                    meshes,
                    materials,
                    &mut rng,
                );
                
                // Add to placement grid
                world_manager.placement_grid.add_entity(
                    position,
                    ContentType::Building,
                    building_size * 0.5,
                );
                
                // Add entity to chunk
                let chunk = world_manager.get_chunk_mut(coord);
                chunk.entities.push(building_entity);
            }
        }
    }
    
    // Mark buildings as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.buildings_generated = true;
}

fn spawn_unified_building(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    position: Vec3,
    distance_from_center: f32,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
    rng: &mut impl Rng,
) -> Entity {
    // Determine building type based on distance from center
    let building_type = if distance_from_center < 500.0 {
        if rng.gen_bool(0.3) { BuildingType::Skyscraper } else { BuildingType::Commercial }
    } else if distance_from_center < 1000.0 {
        if rng.gen_bool(0.6) { BuildingType::Residential } else { BuildingType::Commercial }
    } else {
        BuildingType::Residential
    };
    
    let (width, height) = match building_type {
        BuildingType::Skyscraper => (rng.gen_range(8.0..12.0), rng.gen_range(40.0..80.0)),
        BuildingType::Commercial => (rng.gen_range(10.0..16.0), rng.gen_range(8.0..20.0)),
        BuildingType::Residential => (rng.gen_range(6.0..10.0), rng.gen_range(6.0..15.0)),
        _ => (rng.gen_range(4.0..8.0), rng.gen_range(3.0..8.0)),
    };
    
    let material_color = match building_type {
        BuildingType::Skyscraper => Color::srgb(0.7, 0.7, 0.8),
        BuildingType::Commercial => Color::srgb(0.5, 0.7, 0.9),
        BuildingType::Residential => Color::srgb(0.8, 0.6, 0.4),
        _ => Color::srgb(0.6, 0.6, 0.6),
    };
    
    commands.spawn((
        UnifiedChunkEntity {
            coord: chunk_coord,
            layer: ContentLayer::Buildings,
        },
        Building {
            building_type: crate::components::world::BuildingType::Generic,
            height,
            scale: Vec3::new(width, height, width),
        },
        Mesh3d(meshes.add(Cuboid::new(width, height, width))),
        MeshMaterial3d(materials.add(material_color)),
        Transform::from_translation(Vec3::new(position.x, height * 0.5, position.z)),
        RigidBody::Fixed,
        Collider::cuboid(width * 0.5, height * 0.5, width * 0.5),
        CollisionGroups::new(STATIC_GROUP, Group::ALL),
        Cullable { 
            max_distance: 300.0, 
            is_culled: false 
        },
        DynamicContent {
            content_type: ContentType::Building,
        },
    )).id()
}

/// Layer 3: Vehicle Generation System
pub fn vehicle_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) 
                && chunk.buildings_generated 
                && !chunk.vehicles_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_vehicles_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_vehicles_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    let mut rng = rand::thread_rng();
    let chunk_center = coord.to_world_pos();
    let half_size = UNIFIED_CHUNK_SIZE * 0.5;
    
    // Generate vehicles only on roads
    let vehicle_attempts = 5; // Conservative number to prevent overcrowding
    
    for _ in 0..vehicle_attempts {
        let local_x = rng.gen_range(-half_size..half_size);
        let local_z = rng.gen_range(-half_size..half_size);
        let position = Vec3::new(chunk_center.x + local_x, 0.0, chunk_center.z + local_z);
        
        // Only spawn on roads with sufficient spacing
        if is_on_road_unified(position, &world_manager.road_network) {
            if world_manager.placement_grid.can_place(
                position,
                ContentType::Vehicle,
                4.0, // Vehicle radius
                25.0, // Minimum distance between vehicles
            ) {
                let vehicle_entity = spawn_unified_vehicle(
                    commands,
                    coord,
                    position,
                    meshes,
                    materials,
                    &mut rng,
                );
                
                // Add to placement grid
                world_manager.placement_grid.add_entity(
                    position,
                    ContentType::Vehicle,
                    4.0,
                );
                
                // Add entity to chunk
                let chunk = world_manager.get_chunk_mut(coord);
                chunk.entities.push(vehicle_entity);
            }
        }
    }
    
    // Mark vehicles as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.vehicles_generated = true;
}

fn spawn_unified_vehicle(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    position: Vec3,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
    rng: &mut impl Rng,
) -> Entity {
    let car_colors = [
        Color::srgb(1.0, 0.0, 0.0), // Red
        Color::srgb(0.0, 0.0, 1.0), // Blue
        Color::srgb(0.0, 1.0, 0.0), // Green
        Color::srgb(1.0, 1.0, 0.0), // Yellow
        Color::srgb(0.5, 0.5, 0.5), // Gray
        Color::srgb(1.0, 1.0, 1.0), // White
        Color::srgb(0.0, 0.0, 0.0), // Black
    ];
    
    let color = car_colors[rng.gen_range(0..car_colors.len())];
    
    let car_entity = commands.spawn((
        UnifiedChunkEntity {
            coord: chunk_coord,
            layer: ContentLayer::Vehicles,
        },
        Car,
        RigidBody::Dynamic,
        Collider::cuboid(1.0, 0.5, 2.0),
        LockedAxes::ROTATION_LOCKED_X | LockedAxes::ROTATION_LOCKED_Z,
        Velocity::zero(),
        Transform::from_xyz(position.x, 1.5, position.z),
        VehicleVisibilityBundle::default(),
        Cullable { max_distance: 150.0, is_culled: false },
        CollisionGroups::new(VEHICLE_GROUP, STATIC_GROUP | VEHICLE_GROUP | CHARACTER_GROUP),
        Damping { linear_damping: 1.0, angular_damping: 5.0 },
        DynamicContent {
            content_type: ContentType::Vehicle,
        },
    )).id();
    
    // Car body
    commands.spawn((
        Mesh3d(meshes.add(Cuboid::new(1.8, 0.6, 3.6))),
        MeshMaterial3d(materials.add(color)),
        Transform::from_xyz(0.0, 0.0, 0.0),
        ChildOf(car_entity),
        VisibleChildBundle::default(),
    ));
    
    car_entity
}

/// Layer 4: Vegetation Generation System
pub fn vegetation_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) 
                && chunk.vehicles_generated 
                && !chunk.vegetation_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_vegetation_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_vegetation_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    let mut rng = rand::thread_rng();
    let chunk_center = coord.to_world_pos();
    let half_size = UNIFIED_CHUNK_SIZE * 0.5;
    
    // Generate trees and vegetation in open areas
    let vegetation_attempts = 8;
    
    for _ in 0..vegetation_attempts {
        let local_x = rng.gen_range(-half_size..half_size);
        let local_z = rng.gen_range(-half_size..half_size);
        let position = Vec3::new(chunk_center.x + local_x, 0.0, chunk_center.z + local_z);
        
        // Only spawn vegetation away from roads and buildings
        if !is_on_road_unified(position, &world_manager.road_network) {
            if world_manager.placement_grid.can_place(
                position,
                ContentType::Tree,
                2.0, // Tree radius
                8.0, // Minimum distance between trees
            ) {
                let tree_entity = spawn_unified_tree(
                    commands,
                    coord,
                    position,
                    meshes,
                    materials,
                );
                
                // Add to placement grid
                world_manager.placement_grid.add_entity(
                    position,
                    ContentType::Tree,
                    2.0,
                );
                
                // Add entity to chunk
                let chunk = world_manager.get_chunk_mut(coord);
                chunk.entities.push(tree_entity);
            }
        }
    }
    
    // Mark vegetation as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.vegetation_generated = true;
}

fn spawn_unified_tree(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    position: Vec3,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) -> Entity {
    let tree_entity = commands.spawn((
        UnifiedChunkEntity {
            coord: chunk_coord,
            layer: ContentLayer::Vegetation,
        },
        Transform::from_xyz(position.x, 0.0, position.z),
        Visibility::default(),
        InheritedVisibility::VISIBLE,
        ViewVisibility::default(),
        Cullable { max_distance: 200.0, is_culled: false },
        DynamicContent {
            content_type: ContentType::Tree,
        },
    )).id();
    
    // Tree trunk
    commands.spawn((
        Mesh3d(meshes.add(Cylinder::new(0.3, 8.0))),
        MeshMaterial3d(materials.add(Color::srgb(0.4, 0.2, 0.1))),
        Transform::from_xyz(0.0, 4.0, 0.0),
        RigidBody::Fixed,
        Collider::cylinder(4.0, 0.4),
        CollisionGroups::new(STATIC_GROUP, Group::ALL),
        ChildOf(tree_entity),
        VisibleChildBundle::default(),
    ));
    
    // Tree foliage
    commands.spawn((
        Mesh3d(meshes.add(Sphere::new(3.0))),
        MeshMaterial3d(materials.add(Color::srgb(0.1, 0.6, 0.1))),
        Transform::from_xyz(0.0, 7.0, 0.0),
        ChildOf(tree_entity),
        VisibleChildBundle::default(),
    ));
    
    tree_entity
}

// Utility functions

fn is_on_road_unified(position: Vec3, road_network: &RoadNetwork) -> bool {
    for road in road_network.roads.values() {
        if is_point_on_road_spline_unified(position, road, 2.0) {
            return true;
        }
    }
    false
}

fn is_point_on_road_spline_unified(position: Vec3, road: &RoadSpline, tolerance: f32) -> bool {
    let samples = 20; // Reduced samples for performance
    let width = road.road_type.width();
    
    for i in 0..samples {
        let t = i as f32 / (samples - 1) as f32;
        let road_point = road.evaluate(t);
        let distance = Vec3::new(position.x - road_point.x, 0.0, position.z - road_point.z).length();
        
        if distance <= width * 0.5 + tolerance {
            return true;
        }
    }
    
    false
}

fn create_road_material(road_type: &RoadType, materials: &mut ResMut<Assets<StandardMaterial>>) -> Handle<StandardMaterial> {
    let (base_color, roughness) = match road_type {
        RoadType::Highway => (Color::srgb(0.4, 0.4, 0.45), 0.8),
        RoadType::MainStreet => (Color::srgb(0.35, 0.35, 0.4), 0.8),
        RoadType::SideStreet => (Color::srgb(0.45, 0.45, 0.5), 0.7),
        RoadType::Alley => (Color::srgb(0.5, 0.5, 0.45), 0.6),
    };
    
    materials.add(StandardMaterial {
        base_color,
        perceptual_roughness: roughness,
        metallic: 0.0,
        reflectance: 0.2,
        emissive: Color::BLACK.into(),
        ..default()
    })
}

fn create_marking_material(materials: &mut ResMut<Assets<StandardMaterial>>) -> Handle<StandardMaterial> {
    materials.add(StandardMaterial {
        base_color: Color::srgb(0.95, 0.95, 0.95),
        emissive: LinearRgba::new(0.2, 0.2, 0.2, 1.0),
        perceptual_roughness: 0.6,
        metallic: 0.0,
        reflectance: 0.5,
        ..default()
    })
}

// Building types (matching existing enum)
#[derive(Clone, Copy)]
enum BuildingType {
    Residential,
    Commercial,
    Skyscraper,
}
